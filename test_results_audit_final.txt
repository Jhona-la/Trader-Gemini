============================= test session starts =============================
platform win32 -- Python 3.13.5, pytest-9.0.1, pluggy-1.6.0
rootdir: C:\Users\jhona\Documents\Proyectos\Trader Gemini
collected 50 items

tests\test_binance_loader_refactor.py .                                  [  2%]
tests\test_connectivity_v2.py F                                          [  4%]
tests\test_database.py ....                                              [ 12%]
tests\test_exits.py .....                                                [ 22%]
tests\test_integrity.py ..                                               [ 26%]
tests\test_math.py ....                                                  [ 34%]
tests\test_persistence.py ...                                            [ 40%]
tests\test_recovery.py .F                                                [ 44%]
tests\test_risk_engine.py FFFFF                                          [ 54%]
tests\test_risk_manager.py .......                                       [ 68%]
tests\test_strategies.py .....                                           [ 78%]
tests\test_timestamps.py ......                                          [ 90%]
tests\test_tp1_forensic.py F                                             [ 92%]
tests\test_validation.py ....                                            [100%]

================================== FAILURES ===================================
_______________________________ test_websocket ________________________________
async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted
_____________________ test_crash_recovery_with_portfolio ______________________

    def test_crash_recovery_with_portfolio():
        """Test crash recovery using Portfolio restoration"""
        print("\n" + "="*70)
        print("TEST: Crash Recovery with Portfolio")
        print("="*70)
    
        test_csv = os.path.join(Config.DATA_DIR, "test_trades.csv")
        test_status = os.path.join(Config.DATA_DIR, "test_status.csv")
    
        # Create portfolio and open positions
        portfolio1 = Portfolio(
            initial_capital=10000.0,
            csv_path=test_csv,
            status_path=test_status
        )
    
        try:
            # Open two positions
            buy_btc = FillEvent(
                timeindex=datetime.now(timezone.utc),
                symbol='BTC/USDT',
                exchange='BINANCE',
                quantity=0.01,
                direction='BUY',
                fill_cost=500.0
            )
            buy_btc.strategy_id = 'Strategy1'
    
            buy_eth = FillEvent(
                timeindex=datetime.now(timezone.utc),
                symbol='ETH/USDT',
                exchange='BINANCE',
                quantity=0.5,
                direction='BUY',
                fill_cost=1500.0
            )
            buy_eth.strategy_id = 'Strategy2'
    
            portfolio1.update_fill(buy_btc)
            portfolio1.update_fill(buy_eth)
    
            print("  \u2705 Created 2 open positions")
            print(f"     - BTC/USDT: 0.01")
            print(f"     - ETH/USDT: 0.5")
    
            # Close portfolio (simulate crash)
            portfolio1.db.close()
            print("\\n  \U0001f4a5 Simulated crash (portfolio closed)")
    
            # Create new portfolio instance (simulate restart)
            portfolio2 = Portfolio(
                initial_capital=10000.0,
                csv_path=test_csv,
                status_path=test_status
            )
    
            print("\\n  \U0001f504 Attempting to restore state from DB...")
            recovery_success = portfolio2.restore_state_from_db()
    
            assert recovery_success, "State restoration failed"
            print("  \u2705 State restoration successful")
    
            # Verify positions were restored
            assert len(portfolio2.positions) >= 2, "Not all positions restored"
            assert 'BTC/USDT' in portfolio2.positions, "BTC position not restored"
            assert 'ETH/USDT' in portfolio2.positions, "ETH position not restored"
    
            print(f"  \u2705 Restored {len(portfolio2.positions)} positions")
            print(f"     - BTC/USDT: {portfolio2.positions['BTC/USDT']['quantity']}")
            print(f"     - ETH/USDT: {portfolio2.positions['ETH/USDT']['quantity']}")
    
            portfolio2.db.close()
            return True
    
        except AssertionError as e:
            print(f"  \u274c FAILED: {e}")
            return False
        except Exception as e:
            print(f"  \u274c ERROR: {e}")
            import traceback
            traceback.print_exc()
            return False
        finally:
            # Cleanup
            for file in [test_csv, test_status]:
                if os.path.exists(file):
                    os.remove(file)
    
            test_db_path = os.path.join(Config.DATA_DIR, "trader_gemini.db")
            if os.path.exists(test_db_path):
>               os.remove(test_db_path)
E               PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: 'dashboard/data/spot\\trader_gemini.db'

tests\test_recovery.py:211: PermissionError
---------------------------- Captured stdout call -----------------------------
\n======================================================================\nTEST: Crash Recovery with Portfolio\n======================================================================\n  \u274c ERROR: cannot assign to field 'strategy_id'
---------------------------- Captured stderr call -----------------------------
12:26:44 [INFO] Database tables initialized at dashboard/data/spot\trader_gemini.db
Traceback (most recent call last):
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\tests\test_recovery.py", line 147, in test_crash_recovery_with_portfolio
    buy_btc.strategy_id = 'Strategy1'
    ^^^^^^^^^^^^^^^^^^^
  File "<string>", line 23, in __setattr__
dataclasses.FrozenInstanceError: cannot assign to field 'strategy_id'
------------------------------ Captured log call ------------------------------
INFO     trader_gemini:database.py:99 Database tables initialized at dashboard/data/spot\trader_gemini.db
____________________________ test_position_sizing _____________________________

    def test_position_sizing():
        """Test position sizing calculations"""
        print("\n" + "="*70)
        print("TEST 1: Position Sizing")
        print("="*70)
    
        # Create portfolio and risk manager
        test_csv = os.path.join(Config.DATA_DIR, "test_trades.csv")
        test_status = os.path.join(Config.DATA_DIR, "test_status.csv")
    
        portfolio = Portfolio(initial_capital=10000.0, csv_path=test_csv, status_path=test_status)
        risk_mgr = RiskManager(max_concurrent_positions=5, portfolio=portfolio)
    
        try:
            # Test 1: Basic position sizing (10% of capital for medium account)
            signal = SignalEvent(
                strategy_id="TestStrategy",
                symbol="BTC/USDT",
                datetime=datetime.now(),
                signal_type="LONG",
                strength=1.0
            )
    
            current_price = 50000.0
            position_size = risk_mgr.size_position(signal, current_price)
    
            expected_size = 10000.0 * Config.POSITION_SIZE_MEDIUM_ACCOUNT  # 10% of $10k = $1000
            assert abs(position_size - expected_size) < 1.0, f"Position size mismatch: {position_size} vs {expected_size}"
            print(f"  \u2705 Basic sizing: ${position_size:.2f} (10% of capital)")
    
            # Test 2: Signal strength scaling (50% strength = 50% size)
            signal.strength = 0.5
            position_size_scaled = risk_mgr.size_position(signal, current_price)
    
            expected_scaled = expected_size * 0.5
            assert abs(position_size_scaled - expected_scaled) < 1.0, f"Scaled size mismatch"
            print(f"  \u2705 Strength scaling (0.5): ${position_size_scaled:.2f}")
    
            # Test 3: ATR-based volatility sizing
            signal.strength = 1.0
            signal.atr = 2000.0  # High volatility
            position_size_vol = risk_mgr.size_position(signal, current_price)
    
            # With ATR, size should be capped by volatility
            print(f"  \u2705 ATR-based sizing: ${position_size_vol:.2f} (ATR: {signal.atr})")
    
            return True
    
        except AssertionError as e:
            print(f"  \u274c FAILED: {e}")
            return False
        except Exception as e:
            print(f"  \u274c ERROR: {e}")
            import traceback
            traceback.print_exc()
            return False
        finally:
            portfolio.db.close()
            for file in [test_csv, test_status]:
                if os.path.exists(file):
                    os.remove(file)
            db_path = os.path.join(Config.DATA_DIR, "trader_gemini.db")
            if os.path.exists(db_path):
>               os.remove(db_path)
E               PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: 'dashboard/data/spot\\trader_gemini.db'

tests\test_risk_engine.py:89: PermissionError
---------------------------- Captured stdout call -----------------------------
\n======================================================================\nTEST 1: Position Sizing\n======================================================================\n  \u274c ERROR: SignalEvent validation failed: Datetime naive detectado: 2025-12-06 12:26:44.993048. DEBE ser UTC-aware.
---------------------------- Captured stderr call -----------------------------
12:26:44 [INFO] Database tables initialized at dashboard/data/spot\trader_gemini.db
Traceback (most recent call last):
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\core\events.py", line 44, in __post_init__
    ensure_utc_aware(self.datetime)
    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\utils\time_helpers.py", line 13, in ensure_utc_aware
    raise ValueError(f"Datetime naive detectado: {dt}. DEBE ser UTC-aware.")
ValueError: Datetime naive detectado: 2025-12-06 12:26:44.993048. DEBE ser UTC-aware.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\tests\test_risk_engine.py", line 41, in test_position_sizing
    signal = SignalEvent(
        strategy_id="TestStrategy",
    ...<3 lines>...
        strength=1.0
    )
  File "<string>", line 9, in __init__
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\core\events.py", line 46, in __post_init__
    raise ValueError(f"SignalEvent validation failed: {e}")
ValueError: SignalEvent validation failed: Datetime naive detectado: 2025-12-06 12:26:44.993048. DEBE ser UTC-aware.
------------------------------ Captured log call ------------------------------
INFO     trader_gemini:database.py:99 Database tables initialized at dashboard/data/spot\trader_gemini.db
________________________ test_max_concurrent_positions ________________________

    def test_max_concurrent_positions():
        """Test max concurrent positions enforcement"""
        print("\n" + "="*70)
        print("TEST 2: Max Concurrent Positions")
        print("="*70)
    
        test_csv = os.path.join(Config.DATA_DIR, "test_trades.csv")
        test_status = os.path.join(Config.DATA_DIR, "test_status.csv")
    
        portfolio = Portfolio(initial_capital=10000.0, csv_path=test_csv, status_path=test_status)
        risk_mgr = RiskManager(max_concurrent_positions=3, portfolio=portfolio)
    
        try:
            # Simulate 3 open positions
            portfolio.positions = {
                'BTC/USDT': {'quantity': 0.01, 'avg_price': 50000, 'current_price': 50000},
                'ETH/USDT': {'quantity': 0.5, 'avg_price': 3000, 'current_price': 3000},
                'SOL/USDT': {'quantity': 10, 'avg_price': 100, 'current_price': 100}
            }
    
            open_count = sum(1 for pos in portfolio.positions.values() if pos['quantity'] != 0)
            assert open_count == 3, f"Expected 3 positions, got {open_count}"
            print(f"  \u2705 Created {open_count} open positions")
    
            # Try to open 4th position (should be rejected)
            signal = SignalEvent(
                strategy_id="TestStrategy",
                symbol="AVAX/USDT",
                datetime=datetime.now(),
                signal_type="LONG",
                strength=1.0
            )
    
            order = risk_mgr.generate_order(signal, current_price=50.0)
    
            assert order is None, "Order should be rejected (max positions reached)"
            print("  \u2705 4th position correctly rejected")
    
            # Try EXIT signal (should be allowed)
            exit_signal = SignalEvent(
                strategy_id="TestStrategy",
                symbol="BTC/USDT",
                datetime=datetime.now(),
                signal_type="EXIT",
                strength=1.0
            )
    
            exit_order = risk_mgr.generate_order(exit_signal, current_price=51000.0)
            assert exit_order is not None, "EXIT orders should always be allowed"
            print("  \u2705 EXIT signal correctly allowed")
    
            return True
    
        except AssertionError as e:
            print(f"  \u274c FAILED: {e}")
            return False
        except Exception as e:
            print(f"  \u274c ERROR: {e}")
            import traceback
            traceback.print_exc()
            return False
        finally:
            portfolio.db.close()
            for file in [test_csv, test_status]:
                if os.path.exists(file):
                    os.remove(file)
            db_path = os.path.join(Config.DATA_DIR, "trader_gemini.db")
            if os.path.exists(db_path):
>               os.remove(db_path)
E               PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: 'dashboard/data/spot\\trader_gemini.db'

tests\test_risk_engine.py:159: PermissionError
---------------------------- Captured stdout call -----------------------------
\n======================================================================\nTEST 2: Max Concurrent Positions\n======================================================================\n  \u2705 Created 3 open positions\n  \u274c ERROR: SignalEvent validation failed: Datetime naive detectado: 2025-12-06 12:26:45.010349. DEBE ser UTC-aware.
---------------------------- Captured stderr call -----------------------------
12:26:45 [INFO] Database tables initialized at dashboard/data/spot\trader_gemini.db
Traceback (most recent call last):
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\core\events.py", line 44, in __post_init__
    ensure_utc_aware(self.datetime)
    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\utils\time_helpers.py", line 13, in ensure_utc_aware
    raise ValueError(f"Datetime naive detectado: {dt}. DEBE ser UTC-aware.")
ValueError: Datetime naive detectado: 2025-12-06 12:26:45.010349. DEBE ser UTC-aware.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\tests\test_risk_engine.py", line 116, in test_max_concurrent_positions
    signal = SignalEvent(
        strategy_id="TestStrategy",
    ...<3 lines>...
        strength=1.0
    )
  File "<string>", line 9, in __init__
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\core\events.py", line 46, in __post_init__
    raise ValueError(f"SignalEvent validation failed: {e}")
ValueError: SignalEvent validation failed: Datetime naive detectado: 2025-12-06 12:26:45.010349. DEBE ser UTC-aware.
------------------------------ Captured log call ------------------------------
INFO     trader_gemini:database.py:99 Database tables initialized at dashboard/data/spot\trader_gemini.db
_____________________________ test_risk_per_trade _____________________________

    def test_risk_per_trade():
        """Test max risk per trade enforcement"""
        print("\n" + "="*70)
        print("TEST 3: Max Risk Per Trade")
        print("="*70)
    
        test_csv = os.path.join(Config.DATA_DIR, "test_trades.csv")
        test_status = os.path.join(Config.DATA_DIR, "test_status.csv")
    
        portfolio = Portfolio(initial_capital=10000.0, csv_path=test_csv, status_path=test_status)
        risk_mgr = RiskManager(max_concurrent_positions=5, portfolio=portfolio)
    
        try:
            # Max risk per trade is 1% by default (Config.MAX_RISK_PER_TRADE)
            assert risk_mgr.max_risk_per_trade == Config.MAX_RISK_PER_TRADE
            print(f"  \u2705 Max risk per trade: {risk_mgr.max_risk_per_trade * 100}%")
    
            # With $10k capital and 1% risk, max risk is $100
            max_risk_dollars = 10000.0 * Config.MAX_RISK_PER_TRADE
            assert max_risk_dollars == 100.0, f"Max risk calculation error: {max_risk_dollars}"
            print(f"  \u2705 Max risk amount: ${max_risk_dollars:.2f}")
    
            # Position sizing should respect this limit
            # If we have ATR of $500 (stop distance = 2*ATR = $1000)
            # Position size = Risk / Stop Distance = $100 / $1000 = 0.1 BTC
            signal = SignalEvent(
                strategy_id="TestStrategy",
                symbol="BTC/USDT",
                datetime=datetime.now(),
                signal_type="LONG",
                strength=1.0
            )
            signal.atr = 500.0  # ATR = $500
    
            current_price = 50000.0
            position_size = risk_mgr.size_position(signal, current_price)
    
            # Calculate expected quantity
            stop_distance = signal.atr * 2.0  # $1000
            expected_units = (max_risk_dollars / stop_distance) * current_price
    
            # Position size should be near expected (may be capped)
            print(f"  \u2705 ATR-based risk sizing: ${position_size:.2f} (ATR stop distance: ${stop_distance:.0f})")
    
            return True
    
        except AssertionError as e:
            print(f"  \u274c FAILED: {e}")
            return False
        except Exception as e:
            print(f"  \u274c ERROR: {e}")
            import traceback
            traceback.print_exc()
            return False
        finally:
            portfolio.db.close()
            for file in [test_csv, test_status]:
                if os.path.exists(file):
                    os.remove(file)
            db_path = os.path.join(Config.DATA_DIR, "trader_gemini.db")
            if os.path.exists(db_path):
>               os.remove(db_path)
E               PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: 'dashboard/data/spot\\trader_gemini.db'

tests\test_risk_engine.py:222: PermissionError
---------------------------- Captured stdout call -----------------------------
\n======================================================================\nTEST 3: Max Risk Per Trade\n======================================================================\n  \u2705 Max risk per trade: 1.0%\n  \u2705 Max risk amount: $100.00\n  \u274c ERROR: SignalEvent validation failed: Datetime naive detectado: 2025-12-06 12:26:45.026332. DEBE ser UTC-aware.
---------------------------- Captured stderr call -----------------------------
12:26:45 [INFO] Database tables initialized at dashboard/data/spot\trader_gemini.db
Traceback (most recent call last):
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\core\events.py", line 44, in __post_init__
    ensure_utc_aware(self.datetime)
    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\utils\time_helpers.py", line 13, in ensure_utc_aware
    raise ValueError(f"Datetime naive detectado: {dt}. DEBE ser UTC-aware.")
ValueError: Datetime naive detectado: 2025-12-06 12:26:45.026332. DEBE ser UTC-aware.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\tests\test_risk_engine.py", line 186, in test_risk_per_trade
    signal = SignalEvent(
        strategy_id="TestStrategy",
    ...<3 lines>...
        strength=1.0
    )
  File "<string>", line 9, in __init__
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\core\events.py", line 46, in __post_init__
    raise ValueError(f"SignalEvent validation failed: {e}")
ValueError: SignalEvent validation failed: Datetime naive detectado: 2025-12-06 12:26:45.026332. DEBE ser UTC-aware.
------------------------------ Captured log call ------------------------------
INFO     trader_gemini:database.py:99 Database tables initialized at dashboard/data/spot\trader_gemini.db
_________________________ test_stop_loss_calculations _________________________

    def test_stop_loss_calculations():
        """Test stop-loss trigger calculations"""
        print("\n" + "="*70)
        print("TEST 4: Stop-Loss Calculations")
        print("="*70)
    
        test_csv = os.path.join(Config.DATA_DIR, "test_trades.csv")
        test_status = os.path.join(Config.DATA_DIR, "test_status.csv")
    
        portfolio = Portfolio(initial_capital=10000.0, csv_path=test_csv, status_path=test_status)
        risk_mgr = RiskManager(max_concurrent_positions=5, portfolio=portfolio)
    
        try:
            # Create a losing position (price dropped 2.5%)
            portfolio.positions = {
                'BTC/USDT': {
                    'quantity': 0.01,
                    'avg_price': 50000.0,
                    'current_price': 48750.0,  # -2.5% loss
                    'high_water_mark': 50000.0,
                    'stop_distance': 1000.0  # 2% of 50k = $1000
                }
            }
    
            # Check if stop-loss should trigger
            stop_signals = risk_mgr.check_stops(portfolio, None)
    
            # Should trigger because loss > 2%
            assert len(stop_signals) > 0, "Stop-loss should trigger at -2.5%"
            assert stop_signals[0].signal_type == 'EXIT'
            print(f"  \u2705 Stop-loss triggered at -2.5%")
    
            # TEST TAKE-PROFIT (TRAILING STOP SIMULATION)
            # Scenario: Price rallied from $3000 to $3100 (+3.33%), then retraced to $3070
            portfolio.positions.clear()
            portfolio.positions['ETH/USDT'] = {
                'quantity': 0.5,
                'avg_price': 3000.0,          # Entry price
                'current_price': 3070.0,      # Current: +2.33% profit (dropped from HWM)
                'high_water_mark': 3100.0,    # Peak: +3.33% profit
                'stop_distance': 60.0
            }
    
            # Mathematical verification:
            # Entry: $3000
            # HWM: $3100 (+3.33%)
            # Current: $3070 (+2.33%)
            # unrealized_pnl_pct = (3070-3000)/3000*100 = 2.33%
            # This triggers TP2 (>= 2%)
            #
            # TP2 Calculation:
            # gain_from_entry = 3100 - 3000 = 100
            # trail_distance = 100 * 0.25 = 25 (25% retracement allowed)
            # stop_price = 3100 - 25 = 3075
            # min_stop = 3000 * 1.015 = 3045 (lock at least +1.5%)
            # stop_price = max(3075, 3045) = 3075
            #
            # Trigger condition: current_price (3070) < stop_price (3075) \u2713
    
            tp_signals = risk_mgr.check_stops(portfolio, None)
    
            eth_signals = [s for s in tp_signals if s.symbol == 'ETH/USDT']
            assert len(eth_signals) > 0, f"Take-profit (TP2) should trigger. Got {len(eth_signals)} signals"
            print(f"  \u2705 Take-profit (TP2) triggered with trailing stop from HWM")
    
            return True
    
        except AssertionError as e:
            print(f"  \u274c FAILED: {e}")
            return False
        except Exception as e:
            print(f"  \u274c ERROR: {e}")
            import traceback
            traceback.print_exc()
            return False
        finally:
            portfolio.db.close()
            for file in [test_csv, test_status]:
                if os.path.exists(file):
                    os.remove(file)
            db_path = os.path.join(Config.DATA_DIR, "trader_gemini.db")
            if os.path.exists(db_path):
>               os.remove(db_path)
E               PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: 'dashboard/data/spot\\trader_gemini.db'

tests\test_risk_engine.py:306: PermissionError
---------------------------- Captured stdout call -----------------------------
\n======================================================================\nTEST 4: Stop-Loss Calculations\n======================================================================\n\U0001f6d1 Stop Loss Hit for BTC/USDT! Price: 48750.0000, Entry: 50000.0000, Stop: 49000.0000 (Loss: -2.50%)\n  \u2705 Stop-loss triggered at -2.5%\n\U0001f4b0 TP3 Hit for ETH/USDT! Price: 3070.0000, Entry: 3000.0000, HWM: 3100.0000 (Profit: +2.33%)\n  \u2705 Take-profit (TP2) triggered with trailing stop from HWM
---------------------------- Captured stderr call -----------------------------
12:26:45 [INFO] Database tables initialized at dashboard/data/spot\trader_gemini.db
------------------------------ Captured log call ------------------------------
INFO     trader_gemini:database.py:99 Database tables initialized at dashboard/data/spot\trader_gemini.db
___________________________ test_minimum_order_size ___________________________

    def test_minimum_order_size():
        """Test minimum order size enforcement"""
        print("\n" + "="*70)
        print("TEST 5: Minimum Order Size (Fat Finger Protection)")
        print("="*70)
    
        test_csv = os.path.join(Config.DATA_DIR, "test_trades.csv")
        test_status = os.path.join(Config.DATA_DIR, "test_status.csv")
    
        portfolio = Portfolio(initial_capital=10000.0, csv_path=test_csv, status_path=test_status)
        risk_mgr = RiskManager(max_concurrent_positions=5, portfolio=portfolio)
    
        try:
            # Try to create a tiny order ($3) - should be rejected
            signal = SignalEvent(
                strategy_id="TestStrategy",
                symbol="BTC/USDT",
                datetime=datetime.now(),
                signal_type="LONG",
                strength=0.0003  # Very weak signal
            )
    
            current_price = 50000.0
            position_size = risk_mgr.size_position(signal, current_price)
    
            # Position size will be tiny due to low strength
            print(f"  \U0001f4cf Calculated size: ${position_size:.2f}")
    
            # generate_order should reject orders < $5
            order = risk_mgr.generate_order(signal, current_price)
    
            if position_size < 5.0:
                assert order is None, "Tiny orders should be rejected"
                print("  \u2705 Order < $5 correctly rejected")
            else:
                print("  \u26a0\ufe0f  Order size above minimum, cannot test rejection")
    
            return True
    
        except AssertionError as e:
            print(f"  \u274c FAILED: {e}")
            return False
        except Exception as e:
            print(f"  \u274c ERROR: {e}")
            import traceback
            traceback.print_exc()
            return False
        finally:
            portfolio.db.close()
            for file in [test_csv, test_status]:
                if os.path.exists(file):
                    os.remove(file)
            db_path = os.path.join(Config.DATA_DIR, "trader_gemini.db")
            if os.path.exists(db_path):
>               os.remove(db_path)
E               PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: 'dashboard/data/spot\\trader_gemini.db'

tests\test_risk_engine.py:362: PermissionError
---------------------------- Captured stdout call -----------------------------
\n======================================================================\nTEST 5: Minimum Order Size (Fat Finger Protection)\n======================================================================\n  \u274c ERROR: SignalEvent validation failed: Datetime naive detectado: 2025-12-06 12:26:45.057494. DEBE ser UTC-aware.
---------------------------- Captured stderr call -----------------------------
12:26:45 [INFO] Database tables initialized at dashboard/data/spot\trader_gemini.db
Traceback (most recent call last):
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\core\events.py", line 44, in __post_init__
    ensure_utc_aware(self.datetime)
    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\utils\time_helpers.py", line 13, in ensure_utc_aware
    raise ValueError(f"Datetime naive detectado: {dt}. DEBE ser UTC-aware.")
ValueError: Datetime naive detectado: 2025-12-06 12:26:45.057494. DEBE ser UTC-aware.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\tests\test_risk_engine.py", line 322, in test_minimum_order_size
    signal = SignalEvent(
        strategy_id="TestStrategy",
    ...<3 lines>...
        strength=0.0003  # Very weak signal
    )
  File "<string>", line 9, in __init__
  File "C:\Users\jhona\Documents\Proyectos\Trader Gemini\core\events.py", line 46, in __post_init__
    raise ValueError(f"SignalEvent validation failed: {e}")
ValueError: SignalEvent validation failed: Datetime naive detectado: 2025-12-06 12:26:45.057494. DEBE ser UTC-aware.
------------------------------ Captured log call ------------------------------
INFO     trader_gemini:database.py:99 Database tables initialized at dashboard/data/spot\trader_gemini.db
______________________________ test_tp1_forensic ______________________________

    def test_tp1_forensic():
        """FORENSIC TEST: TP1 Trailing Stop - Debug Mode"""
        print("\n" + "="*70)
        print("\U0001f52c TP1 FORENSIC TEST - CoG-RA AUDIT")
        print("="*70)
    
        test_csv = os.path.join(Config.DATA_DIR, "test_trades.csv")
        test_status = os.path.join(Config.DATA_DIR, "test_status.csv")
    
        portfolio = Portfolio(initial_capital=10000.0, csv_path=test_csv, status_path=test_status)
        risk_mgr = RiskManager(max_concurrent_positions=5, portfolio=portfolio)
    
        try:
            print("\\n\U0001f4ca SCENARIO SETUP:")
            print("  Entry Price: $3000")
            print("  HWM (Peak): $3045 (+1.5% reached)")
            print("  Current Price: Testing different values...")
    
            # SCENARIO 1: Current at +1.0% exactly (should enter TP1 logic)
            print("\n=== TEST 1: Current = $3030 (+1.0% profit) ===")
            portfolio.positions['BTC/USDT'] = {
                'quantity': 1.0,
                'avg_price': 3000.0,
                'current_price': 3030.0,
                'high_water_mark': 3045.0,
                'stop_distance': 60.0
            }
    
            # DEBUGGING: Calculate what the code will see
            entry = 3000.0
            current = 3030.0
            hwm = 3045.0
    
            unrealized_pnl_pct = ((current - entry) / entry) * 100
            print(f"  \U0001f4a1 Unrealized PnL%: {unrealized_pnl_pct:.4f}%")
            print(f"  \U0001f4a1 TP1 Threshold: 1.0%")
            print(f"  \U0001f4a1 Enters TP1 logic? {unrealized_pnl_pct >= 1.0}")
    
            if unrealized_pnl_pct >= 1.0:
                gain_from_entry = hwm - entry
                trail_distance = gain_from_entry * 0.5
                stop_price = hwm - trail_distance
                breakeven_stop = entry * 1.003
                final_stop = max(stop_price, breakeven_stop)
    
                print(f"  \U0001f4a1 Gain from entry: ${gain_from_entry:.2f}")
                print(f"  \U0001f4a1 Trail distance (50%): ${trail_distance:.2f}")
                print(f"  \U0001f4a1 Raw stop price: ${stop_price:.2f}")
                print(f"  \U0001f4a1 Breakeven stop (+0.3%): ${breakeven_stop:.2f}")
                print(f"  \U0001f4a1 Final stop price: ${final_stop:.2f}")
                print(f"  \U0001f4a1 Should trigger? {current < final_stop}")
    
            stop_signals = risk_mgr.check_stops(portfolio, None)
    
            print(f"\\n  \U0001f4e1 Signals generated: {len(stop_signals)}")
            if len(stop_signals) == 0:
                print("  \u274c NO SIGNAL - Current price above stop")
                print(f"  \U0001f50d Need current < ${final_stop:.2f} to trigger")
    
                # SCENARIO 2: Drop current price below stop
                print("\n=== TEST 2: Dropping current to trigger TP1 ===")
                drop_price = final_stop - 0.5  # Drop slightly below stop
                portfolio.positions['BTC/USDT']['current_price'] = drop_price
                print(f"  \U0001f4c9 New current price: ${drop_price:.2f}")
    
                stop_signals = risk_mgr.check_stops(portfolio, None)
                print(f"  \U0001f4e1 Signals after drop: {len(stop_signals)}")
    
                if len(stop_signals) > 0:
                    print(f"  \u2705 TP1 TRIGGERED at ${drop_price:.2f}")
                    print(f"  \u2705 FORENSIC CONCLUSION: TP1 logic is CORRECT")
                    print(f"  \U0001f41b BUG IDENTIFIED: Test was using price ABOVE stop")
                    return True
                else:
                    print(f"  \u274c STILL NO SIGNAL")
                    print(f"  \U0001f41b CRITICAL BUG: TP1 logic may be broken")
    
                    # Final debugging: Recalculate with new price
                    new_current = drop_price
                    new_pnl_pct = ((new_current - entry) / entry) * 100
                    print(f"\\n  \U0001f50d DEEP DEBUG:")
                    print(f"    Entry: ${entry}")
                    print(f"    Current: ${new_current}")
                    print(f"    HWM: ${hwm}")
                    print(f"    PnL%: {new_pnl_pct:.4f}%")
                    print(f"    >= 1.0%? {new_pnl_pct >= 1.0}")
    
                    return False
            else:
                print(f"  \u2705 TP1 triggered immediately")
                return True
    
        except Exception as e:
            print(f"  \u274c ERROR: {e}")
            import traceback
            traceback.print_exc()
            return False
        finally:
            portfolio.db.close()
            for file in [test_csv, test_status]:
                if os.path.exists(file):
                    os.remove(file)
            db_path = os.path.join(Config.DATA_DIR, "trader_gemini.db")
            if os.path.exists(db_path):
>               os.remove(db_path)
E               PermissionError: [WinError 32] The process cannot access the file because it is being used by another process: 'dashboard/data/spot\\trader_gemini.db'

tests\test_tp1_forensic.py:121: PermissionError
---------------------------- Captured stdout call -----------------------------
\n======================================================================\n\U0001f52c TP1 FORENSIC TEST - CoG-RA AUDIT\n======================================================================\n\n\U0001f4ca SCENARIO SETUP:\n  Entry Price: $3000\n  HWM (Peak): $3045 (+1.5% reached)\n  Current Price: Testing different values...\n\n=== TEST 1: Current = $3030 (+1.0% profit) ===\n  \U0001f4a1 Unrealized PnL%: 1.0000%\n  \U0001f4a1 TP1 Threshold: 1.0%\n  \U0001f4a1 Enters TP1 logic? True\n  \U0001f4a1 Gain from entry: $45.00\n  \U0001f4a1 Trail distance (50%): $22.50\n  \U0001f4a1 Raw stop price: $3022.50\n  \U0001f4a1 Breakeven stop (+0.3%): $3009.00\n  \U0001f4a1 Final stop price: $3022.50\n  \U0001f4a1 Should trigger? False\n\n  \U0001f4e1 Signals generated: 0\n  \u274c NO SIGNAL - Current price above stop\n  \U0001f50d Need current < $3022.50 to trigger\n\n=== TEST 2: Dropping current to trigger TP1 ===\n  \U0001f4c9 New current price: $3022.00\n\U0001f4b0 TP1 Hit for BTC/USDT! Price: 3022.0000, Entry: 3000.0000, HWM: 3045.0000 (Profit: +0.73%)\n  \U0001f4e1 Signals after drop: 1\n  \u2705 TP1 TRIGGERED at $3022.00\n  \u2705 FORENSIC CONCLUSION: TP1 logic is CORRECT\n  \U0001f41b BUG IDENTIFIED: Test was using price ABOVE stop
---------------------------- Captured stderr call -----------------------------
12:26:45 [INFO] Database tables initialized at dashboard/data/spot\trader_gemini.db
------------------------------ Captured log call ------------------------------
INFO     trader_gemini:database.py:99 Database tables initialized at dashboard/data/spot\trader_gemini.db
============================== warnings summary ===============================
.venv\Lib\site-packages\binance\ws\websocket_api.py:4
.venv\Lib\site-packages\binance\ws\websocket_api.py:4
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\binance\ws\websocket_api.py:4: DeprecationWarning: websockets.WebSocketClientProtocol is deprecated
    from websockets import WebSocketClientProtocol  # type: ignore

.venv\Lib\site-packages\websockets\legacy\__init__.py:6
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\websockets\legacy\__init__.py:6: DeprecationWarning: websockets.legacy is deprecated; see https://websockets.readthedocs.io/en/stable/howto/upgrade.html for upgrade instructions
    warnings.warn(  # deprecated in 14.0 - 2024-11-09

tests/test_database.py::test_database_initialization
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_database.py::test_database_initialization returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_database.py::test_trade_logging
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\data\database.py:113: DeprecationWarning: The default datetime adapter is deprecated as of Python 3.12; see the sqlite3 documentation for suggested replacement recipes
    cursor.execute('''

tests/test_database.py::test_trade_logging
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_database.py::test_trade_logging returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_database.py::test_position_persistence
tests/test_database.py::test_crash_recovery_simulation
tests/test_database.py::test_crash_recovery_simulation
tests/test_database.py::test_crash_recovery_simulation
tests/test_exits.py::test_hwm_tracking
tests/test_exits.py::test_hwm_tracking
tests/test_persistence.py::TestPersistence::test_close_position_persistence
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\data\database.py:170: DeprecationWarning: The default datetime adapter is deprecated as of Python 3.12; see the sqlite3 documentation for suggested replacement recipes
    cursor.execute('''

tests/test_database.py::test_position_persistence
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_database.py::test_position_persistence returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_database.py::test_crash_recovery_simulation
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_database.py::test_crash_recovery_simulation returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_exits.py::test_tp1_trailing_stop
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_exits.py::test_tp1_trailing_stop returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_exits.py::test_tp2_trailing_stop
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_exits.py::test_tp2_trailing_stop returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_exits.py::test_tp3_trailing_stop
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_exits.py::test_tp3_trailing_stop returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_exits.py::test_stop_loss
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_exits.py::test_stop_loss returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_exits.py::test_hwm_tracking
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_exits.py::test_hwm_tracking returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_integrity.py::test_core_imports
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_integrity.py::test_core_imports returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_integrity.py::test_no_syntax_errors
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_integrity.py::test_no_syntax_errors returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_persistence.py::TestPersistence::test_atomic_persistence_and_recovery
tests/test_persistence.py::TestPersistence::test_close_position_persistence
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\data\database.py:244: DeprecationWarning: The default datetime adapter is deprecated as of Python 3.12; see the sqlite3 documentation for suggested replacement recipes
    cursor.execute('''

tests/test_persistence.py::TestPersistence::test_atomic_persistence_and_recovery
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\data\database.py:268: DeprecationWarning: The default datetime adapter is deprecated as of Python 3.12; see the sqlite3 documentation for suggested replacement recipes
    cursor.execute('''

tests/test_recovery.py::test_portfolio_db_integration
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_recovery.py::test_portfolio_db_integration returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_strategies.py::test_rsi_calculation
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_strategies.py::test_rsi_calculation returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_strategies.py::test_macd_calculation
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_strategies.py::test_macd_calculation returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_strategies.py::test_bollinger_bands
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_strategies.py::test_bollinger_bands returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_strategies.py::test_atr_calculation
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_strategies.py::test_atr_calculation returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_strategies.py::test_ml_confluence_scoring
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_strategies.py::test_ml_confluence_scoring returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_validation.py::test_no_hardcoded_secrets
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_validation.py::test_no_hardcoded_secrets returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_validation.py::test_env_file_exists
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_validation.py::test_env_file_exists returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_validation.py::test_config_validation
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_validation.py::test_config_validation returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_validation.py::test_exception_handling
  C:\Users\jhona\Documents\Proyectos\Trader Gemini\.venv\Lib\site-packages\_pytest\python.py:170: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_validation.py::test_exception_handling returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/test_connectivity_v2.py::test_websocket - Failed: async def func...
FAILED tests/test_recovery.py::test_crash_recovery_with_portfolio - Permissio...
FAILED tests/test_risk_engine.py::test_position_sizing - PermissionError: [Wi...
FAILED tests/test_risk_engine.py::test_max_concurrent_positions - PermissionE...
FAILED tests/test_risk_engine.py::test_risk_per_trade - PermissionError: [Win...
FAILED tests/test_risk_engine.py::test_stop_loss_calculations - PermissionErr...
FAILED tests/test_risk_engine.py::test_minimum_order_size - PermissionError: ...
FAILED tests/test_tp1_forensic.py::test_tp1_forensic - PermissionError: [WinE...
================== 8 failed, 42 passed, 35 warnings in 4.71s ==================
