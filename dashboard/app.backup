import streamlit as st
import pandas as pd
import time
import plotly.express as px
import plotly.graph_objects as go
import json
import os

st.set_page_config(page_title="Trader Gemini Dashboard", layout="wide")

st.title("Trader Gemini - Live Dashboard ðŸš€")

# Auto-refresh DISABLED (manual refresh only to prevent freezing)
auto_refresh = False  # User refreshes page manually

# Paths
TRADES_PATH = "dashboard/data/trades.csv"
STATUS_PATH = "dashboard/data/status.csv"

# Load Data with caching (refreshes every 3 seconds)
@st.cache_data(ttl=3)
def load_data():
    """
    Load trading data from CSV files with caching.
    Only loads last 500 rows of status to prevent memory bloat.
    """
    try:
        # Load recent status data (10,000 rows = ~14 hours at 5s intervals)
        try:
            # Robust CSV reading: skip bad lines, handle mixed types
            status_df = pd.read_csv(STATUS_PATH, on_bad_lines='skip', encoding='utf-8', low_memory=False)
            
            # Ensure timestamp column exists
            if 'timestamp' not in status_df.columns:
                return pd.DataFrame(), pd.DataFrame()
                
            # Parse dates with coercion (invalid dates become NaT)
            status_df['timestamp'] = pd.to_datetime(status_df['timestamp'], format='mixed', errors='coerce', utc=True)
            
            # Drop rows with invalid dates
            status_df.dropna(subset=['timestamp'], inplace=True)
            
            # Localize
import streamlit as st
import pandas as pd
import time
import plotly.express as px
import plotly.graph_objects as go
import json
import os

st.set_page_config(page_title="Trader Gemini Dashboard", layout="wide")

st.title("Trader Gemini - Live Dashboard ðŸš€")

# Auto-refresh DISABLED (manual refresh only to prevent freezing)
auto_refresh = False  # User refreshes page manually

# Paths
TRADES_PATH = "dashboard/data/trades.csv"
STATUS_PATH = "dashboard/data/status.csv"

# Load Data with caching (refreshes every 3 seconds)
@st.cache_data(ttl=3)
def load_data():
    """
    Load trading data from CSV files with caching.
    Only loads last 500 rows of status to prevent memory bloat.
    """
    try:
        # Load recent status data (10,000 rows = ~14 hours at 5s intervals)
        try:
            # Robust CSV reading: skip bad lines, handle mixed types
            status_df = pd.read_csv(STATUS_PATH, on_bad_lines='skip', encoding='utf-8', low_memory=False)
            
            # Ensure timestamp column exists
            if 'timestamp' not in status_df.columns:
                return pd.DataFrame(), pd.DataFrame()
                
            # Parse dates with coercion (invalid dates become NaT)
            status_df['timestamp'] = pd.to_datetime(status_df['timestamp'], format='mixed', errors='coerce', utc=True)
            
            # Drop rows with invalid dates
            status_df.dropna(subset=['timestamp'], inplace=True)
            
            # Localize
            status_df['timestamp'] = status_df['timestamp'].dt.tz_localize(None)
            
        except Exception as e:
            # If file is totally broken, return empty but don't crash
            print(f"CSV Read Error: {e}")
            return pd.DataFrame(), pd.DataFrame()
            
        # Keep only recent data
        # Keep last 50,000 rows (~3 days at 5s intervals = 259,200 rows per day)
        # This allows viewing longer-term performance trends
        if len(status_df) > 50000:
            status_df = status_df.tail(50000)
            
        status_df = status_df.sort_values('timestamp', ascending=True)
        
        # Load all trades (typically fewer rows)
        try:
            trades_df = pd.read_csv(TRADES_PATH, on_bad_lines='skip', encoding='utf-8')
        except:
            trades_df = pd.read_csv(TRADES_PATH, on_bad_lines='skip')
        trades_df['datetime'] = pd.to_datetime(trades_df['datetime'], format='ISO8601', utc=True).dt.tz_localize(None)
        trades_df = trades_df.sort_values('datetime', ascending=False)
        
        return trades_df, status_df
    except FileNotFoundError:
        st.warning("â³ Waiting for bot status data...")
        return pd.DataFrame(), pd.DataFrame()
    except Exception as e:
        st.error(f"Error loading data: {e}")
        st.info("ðŸ’¡ Tip: Try deleting 'dashboard/data/status.csv' and restart the bot to create a fresh file.")
        return pd.DataFrame(), pd.DataFrame()

trades_df, status_df = load_data()

# Top Metrics
if not status_df.empty:
    latest = status_df.iloc[-1]
    
    st.markdown("### ðŸ“Š Portfolio Summary")
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(
            "ðŸ’° Total Equity", 
            f"${latest['total_equity']:,.2f}", 
            delta=f"${latest['total_equity'] - 10000:,.2f}",
            help="**Tu dinero total** = Efectivo + Valor de posiciones abiertas. Empieza en $10,000."
        )
    with col2:
        st.metric(
            "ðŸ’µ Available Cash", 
            f"${latest['cash']:,.2f}", 
            help="**Dinero disponible** para abrir nuevas posiciones. No incluye dinero usado en trades abiertos."
        )
    with col3:
        st.metric(
            "âœ… Realized PnL", 
            f"${latest['realized_pnl']:,.2f}", 
            help="**Ganancias/PÃ©rdidas confirmadas** de trades ya cerrados. Esto es dinero real ganado o perdido."
        )
    with col4:
        st.metric(
            "â³ Unrealized PnL", 
            f"${latest['unrealized_pnl']:,.2f}",
            help="**Ganancias/PÃ©rdidas flotantes** de posiciones todavÃ­a abiertas. Solo se confirman al cerrar."
        )
        
    # Positions Table
    st.subheader("ðŸ“ˆ Current Positions")
    st.caption("ðŸ’¡ **Tip:** Click 'âŒ Close' to manually close a position and take profits/cut losses.")
    
    try:
        positions = json.loads(latest['positions'])
        pos_data = []
        for symbol, data in positions.items():
            if data['quantity'] != 0: # Only show open positions
                current_val = data['quantity'] * data['current_price']
                cost_basis = data['quantity'] * data['avg_price']
                pnl = current_val - cost_basis
                pnl_pct = (pnl / cost_basis) * 100 if cost_basis != 0 else 0
                
                pos_data.append({
                    'Symbol': symbol,
                    'Qty': data['quantity'],
                    'Avg Price': f"${data['avg_price']:.2f}",
                    'Current Price': f"${data['current_price']:.2f}",
                    'Value': f"${current_val:.2f}",
                    'PnL': f"${pnl:.2f} ({pnl_pct:.2f}%)",
                    'PnL_Raw': pnl  # For sorting
                })
        
        if pos_data:
            df_pos = pd.DataFrame(pos_data)
            
            # Calculate Allocation %
            total_value = sum([float(x['Value'].replace('$','').replace(',','')) for x in pos_data])
            if total_value > 0:
                df_pos['Allocation'] = df_pos['Value'].apply(lambda x: float(x.replace('$','').replace(',','')) / total_value * 100)
            else:
                df_pos['Allocation'] = 0
            
            df_pos['Allocation'] = df_pos['Allocation'].map('{:.1f}%'.format)
            
            # Sort by PnL (best performers first)
            df_pos = df_pos.sort_values('PnL_Raw', ascending=False)
            df_pos = df_pos.drop('PnL_Raw', axis=1)
            
            # Display as styled dataframe
            def color_pnl(val):
                if '(-' in val or '-$' in val:
                    return 'color: red'
                elif '$0.00' in val:
                    return 'color: gray'
                else:
                    return 'color: green'

            # Display table with manual close buttons
            st.dataframe(df_pos.style.applymap(color_pnl, subset=['PnL']), use_container_width=True, hide_index=True)
            
            # Manual Close Position Controls
            st.markdown("---")
            st.markdown("#### ðŸŽ¯ Manual Position Control")
            st.caption("Cerrar manualmente una posiciÃ³n (Ãºtil para tomar ganancias o cortar pÃ©rdidas)")
            
            col_close1, col_close2 = st.columns([2, 1])
            with col_close1:
                symbols_open = [x['Symbol'] for x in pos_data]
                selected_symbol = st.selectbox(
                    "Select position to close:",
                    symbols_open,
                    help="Elige quÃ© posiciÃ³n quieres cerrar manualmente"
                )
            
            with col_close2:
                st.write("")  # Spacer
                st.write("")  # Spacer
                if st.button("âŒ Close Position", type="primary", use_container_width=True):
                    # Write close signal to a file that main.py will read
                    try:
                        close_signal_path = "dashboard/data/manual_close.txt"
                        os.makedirs(os.path.dirname(close_signal_path), exist_ok=True)
                        with open(close_signal_path, 'w') as f:
                            f.write(f"{selected_symbol}\n")
                        st.success(f"âœ… Close signal sent for {selected_symbol}! The bot will close it on the next cycle.")
                    except Exception as e:
                        st.error(f"Error sending close signal: {e}")

            # Portfolio Risk Summary
            st.markdown("### ðŸ›¡ï¸ Portfolio Risk")
            long_exposure = sum([float(x['Value'].replace('$','').replace(',','')) for x in pos_data if float(x['Qty']) > 0])
            short_exposure = sum([float(x['Value'].replace('$','').replace(',','')) for x in pos_data if float(x['Qty']) < 0])
            net_exposure = long_exposure - short_exposure
            gross_exposure = long_exposure + short_exposure
            
            equity = latest['total_equity']
            leverage = gross_exposure / equity if equity > 0 else 0
            
            r1, r2, r3, r4 = st.columns(4)
            r1.metric("Long Exposure", f"${long_exposure:,.2f}")
            r2.metric("Short Exposure", f"${short_exposure:,.2f}")
            r3.metric("Net Exposure", f"${net_exposure:,.2f}", help="Longs - Shorts. Positive = Bullish, Negative = Bearish.")
            r4.metric("Leverage", f"{leverage:.2f}x", help="Total Position Value / Equity. > 1.0 means you are borrowing money (margin).")
                
        else:
            st.info("No open positions.")
            
    except Exception as e:
        st.error(f"Error parsing positions: {e}")

    # Equity Curve
    st.subheader("Equity Curve")
    fig = px.line(status_df, x='timestamp', y='total_equity', title="Account Value Over Time")
    st.plotly_chart(fig, use_container_width=True)

    # Advanced Metrics
    st.subheader("Performance Metrics")
    if not trades_df.empty:
        closed_trades = trades_df[trades_df['type'] == 'FILL']
        if not closed_trades.empty:
            # Simple approximation: Pair BUYs and SELLs to calculate PnL per trade
            # This is complex to do perfectly from just fills without a trade ID, 
            # so we will use the Realized PnL from status.csv for the aggregate.
            
            total_trades = len(closed_trades)
            
            # Calculate Win Rate based on Realized PnL changes
            # We look at status_df changes in realized_pnl
            pnl_changes = status_df['realized_pnl'].diff().dropna()
            winning_trades = pnl_changes[pnl_changes > 0]
            losing_trades = pnl_changes[pnl_changes < 0]
            
            num_wins = len(winning_trades)
            num_losses = len(losing_trades)
            win_rate = (num_wins / (num_wins + num_losses)) * 100 if (num_wins + num_losses) > 0 else 0
            
            gross_profit = winning_trades.sum()
            gross_loss = abs(losing_trades.sum())
            profit_factor = gross_profit / gross_loss if gross_loss != 0 else float('inf')
            
            m1, m2, m3 = st.columns(3)
            m1.metric("Win Rate", f"{win_rate:.1f}%", help="Percentage of trades that ended in profit. > 50% is good.")
            m2.metric("Profit Factor", f"{profit_factor:.2f}", help="Gross Profit / Gross Loss. > 1.5 is ideal. < 1.0 means losing money.")
            m3.metric("Total Fills", f"{total_trades}", help="Total number of executed orders (Buys + Sells).")
            
            # Best/Worst Trade
            if not pnl_changes.empty:
                b1, b2 = st.columns(2)
                b1.metric("ðŸ† Best Trade", f"${pnl_changes.max():.2f}", help="The single most profitable trade.")
                b2.metric("ðŸ’€ Worst Trade", f"${pnl_changes.min():.2f}", help="The single biggest loss.")
            
            # PnL Distribution
            st.subheader("Profit/Loss Distribution")
            fig_hist = px.histogram(pnl_changes, nbins=20, title="Trade Outcome Distribution", labels={'value': 'PnL ($)'}, color_discrete_sequence=['#636EFA'])
            fig_hist.update_layout(showlegend=False)
            st.plotly_chart(fig_hist, use_container_width=True)
            
            # Symbol Breakdown
            st.subheader("Activity by Symbol")
            symbol_counts = closed_trades['symbol'].value_counts().reset_index()
            symbol_counts.columns = ['Symbol', 'Trades']
            fig_sym = px.bar(symbol_counts, x='Symbol', y='Trades', title="Trades per Symbol", color='Symbol')
            fig_sym = px.bar(symbol_counts, x='Symbol', y='Trades', title="Trades per Symbol", color='Symbol')
            st.plotly_chart(fig_sym, use_container_width=True)

    # Strategy Performance (Attribution)
    st.subheader("ðŸ† Strategy Performance")
    try:
        if 'strategy_performance' in latest and pd.notna(latest['strategy_performance']):
            strat_perf = json.loads(latest['strategy_performance'])
            if strat_perf:
                strat_data = []
                for strat_id, metrics in strat_perf.items():
                    # Map ID to Name
                    strat_name = "Unknown"
                    if str(strat_id) == '1': strat_name = "Technical (RSI)"
                    elif str(strat_id) == '2': strat_name = "Statistical (Pairs)"
                    elif str(strat_id) == '3': strat_name = "ML (XGBoost)"
                    
                    wins = metrics.get('wins', 0)
                    losses = metrics.get('losses', 0)
                    total = wins + losses
                    win_rate = (wins / total * 100) if total > 0 else 0
                    
                    strat_data.append({
                        'Strategy': strat_name,
                        'PnL': metrics.get('pnl', 0.0),
                        'Trades': metrics.get('trades', 0),
                        'Win Rate': f"{win_rate:.1f}%",
                        'Wins': wins,
                        'Losses': losses
                    })
                
                df_strat = pd.DataFrame(strat_data)
                df_strat = df_strat.sort_values('PnL', ascending=False)
                
                # Format PnL
                df_strat['PnL'] = df_strat['PnL'].apply(lambda x: f"${x:,.2f}")
                
                st.dataframe(df_strat, use_container_width=True, hide_index=True)
            else:
                st.info("No strategy performance data yet.")
        else:
            st.info("Strategy attribution data not available in current status.")
    except Exception as e:
        st.warning(f"Could not parse strategy performance: {e}")

    # Drawdown Analysis
    if not status_df.empty:
        st.subheader("Risk Analysis (Drawdown)")
        status_df['peak'] = status_df['total_equity'].cummax()
        status_df['drawdown'] = (status_df['total_equity'] - status_df['peak']) / status_df['peak'] * 100
        
        fig_dd = px.area(status_df, x='timestamp', y='drawdown', title="Drawdown (%)", color_discrete_sequence=['red'])
        st.plotly_chart(fig_dd, use_container_width=True)

else:
    st.warning("Waiting for bot status data...")

# Recent Activity
st.subheader("Recent Activity")
col1, col2 = st.columns(2)

with col1:
    st.markdown("### Signals")
    if not trades_df.empty:
        signals = trades_df[trades_df['type'] == 'SIGNAL']
        st.dataframe(signals[['datetime', 'symbol', 'direction', 'details']].head(10), hide_index=True)
    else:
        st.info("No signals yet.")

with col2:
    st.markdown("### Fills")
    if not trades_df.empty:
        fills = trades_df[trades_df['type'] == 'FILL']
        # Color code fills
        def color_fills(val):
            color = 'green' if val == 'BUY' else 'red'
            return f'color: {color}'
            
        st.dataframe(fills[['datetime', 'symbol', 'direction', 'quantity', 'price']].head(10).style.applymap(color_fills, subset=['direction']), hide_index=True)
    else:
        st.info("No fills yet.")

# No auto-refresh to prevent freezing
# User manually refreshes page (F5) when needed
st.info("ðŸ’¡ **Tip:** Refresh the page (F5) to update data. No auto-refresh to keep dashboard stable.")
